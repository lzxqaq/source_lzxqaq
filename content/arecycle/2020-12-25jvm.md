---
title: "Java 虚拟机"
date: 2020-12-25T15:06:19+08:00
author: "Shaka"
tags: [
    "Java"
]
draft: true

---
参考自 [CyC2018/CS-Notes](https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md)

* [一、运行时数据区域](#1)
    * [程序计数器](#1.1)
    * [Java 虚拟机栈](#1.2)
    * [本地方法栈](#1.3)
    * [堆](#1.4)
    * [方法区](#1.5)
    * [运行时常量池](#1.6)
    * [直接内存](#1.7)
* [二、垃圾收集](#2)
    * [判断一个对象是否可被回收](#2.1)
    * [引用类型](#2.2)
    * [垃圾收集算法](#2.3)
    * [垃圾收集器](#2.4)
* [三、内存分配和回收策略](#3)
    * [Minor Gc 和 Full Gc](#3.1)
    * [内存分配策略](#3.2)
    * [Full GC 的触发条件](#3.3)
* [四、类加载机制](#4)
    * [类的生命周期](#4.1)
    * [类加载过程](#4.2)
    * [类初始化时机](#4.3)
    * [类与类加载器](#4.4)
    * [类加载器分类](#4.5)
    * [双亲委派模型](#4.6)
    * [自定义类加载器实现](#4.7)

### 一、运行时数据区域 <a name="1"></a>
#### 程序计数器 <a name="1.1"></a>
记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。  

#### Java 虚拟机栈 <a name="1.2"></a>
每个 Java方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。  

可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小，在 JDK 1.4 中默认为 256K，而在 JDK1.5+ 默认为 1M：  
```
java -Xss2M HaskTheJava
```
该区域可能抛出以下异常：  
* 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；  
* 栈进行动态扩展的时如果无法申请到足够的内存，会抛出 OutofMemoryError 异常。  

#### 本地方法栈<a name="1.3"></a>
本地方法栈与 Java 虚拟机栈类似，他们之间的区别只不过是本地方法栈为本地方法服务。  
本地方法一般是用其他语言（C、C++或汇编语言等等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。  

#### 堆 <a name="1.4"></a>
所有对象都在这里分配内存，是垃圾收集的主要区域（"GC堆"）。  
现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采用不同的垃圾回收算法。可以将堆分成两块：  

* 新生代
* 老年代

堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。  

可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。  
```
java -Xms1M -Xmx2M HackTheJava
```

#### 方法区<a name="1.5"></a>
用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。  

和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。  

对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。  

HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存，而不是虚拟机内存。  
方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。  

#### 运行时常量池<a name="1.6"></a>

运行时常量池是方法区的一部分。  

Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。  

除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。

#### 直接内存<a name="1.7"></a>
在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存。

### 二、垃圾回收<a name="2"></a>
垃圾收集主要是针对堆和方法区进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。

#### 判断一个对象是否可被回收<a name="2.1"></a>
##### 1.引用技术算法
（相互引用时，两个对象都无法被回收）
 
##### 2.可达性分析
以 GC Roots为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。
Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容：
* 虚拟机栈中局部变量表中引用的对象
* 本地方法栈 JNI 中引用的对象
* 方法区中类静态属性引用的对象
* 方法区中的常量引用的对象

##### 3.方法区的回收
因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所有在方法区上进行回收性价比不高。

主要是对常量池的回收和对类的卸载。

##### 4.finalize()
类似 C++ 的析构函数，用于关闭外部资源。最好别用，用try-finally等。

#### 引用类型<a name="2.2"></a>
##### 1.强引用
被强引用关联的对象不会被回收。

使用 new 一个新对象来创建强引用。

##### 2.软引用
##### 3.弱引用
##### 4.虚引用

#### 垃圾收集算法<a name="2.3"></a>
##### 1.标记-清除
##### 2.标记-整理
##### 3.复制
##### 4.分代收集
根据对象存活周期将内存划分为几块，不痛块采用适当的收集算法。

一般将堆分为新生代和老生代。

* 新生代使用：复制算法
* 老生代使用：标记-清除 或者 标记-整理 算法

### 四、类加载机制<a name="4"></a>
类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。

#### 类的生命周期<a name="4.1"></a>
包括以下阶段：
* 加载
* 验证
* 准备
* 解析
* 初始化
* 使用
* 卸载
 







































































